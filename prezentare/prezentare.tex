\documentclass[12pt]{article}
\usepackage[romanian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{float}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{geometry}
\usepackage{ragged2e}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{color}
\geometry{a4paper, margin=2.5cm}

\pagestyle{fancy}
\fancyhf{}
\rhead{Grupa 151}
\lhead{Tema 1 de laborator}
\cfoot{\thepage}

\title{\textbf{Tema 1 de laborator}}
\author{Aioanei Florin \and Verzotti Matteo \and Voaides Robert}
\date{}

\begin{document}

\maketitle

\begin{center}
    \textbf{Compararea unor algoritmi de sortare prin comportamentul lor asupra mai multor suite de teste}\\
\end{center}

\vspace{1cm}

\tableofcontents
\newpage

\section{Introducere}

În această lucrare ne propunem să comparăm performanțele mai multor algoritmi de sortare din punct de vedere al complexității teoretice și al performanței practice. Scopul este de a evidenția avantajele și dezavantajele fiecărui algoritm în funcție de dimensiunea și natura datelor de intrare.

\section{Algoritmi analizați}

\begin{itemize}
    \item Quick Sort
    \begin{itemize}
        \item Random Pivot
        \item Median Pivot
        \item Half Pivot
        \item Ternary Quick Sort
    \end{itemize}
    \item Radix Sort
    \begin{itemize}
        \item base 10
        \item base 16
        \item base $2^{16}$
    \end{itemize}
    \item Merge Sort
    \item Intro Sort
    \item Tim Sort
    \item Shell Sort
\end{itemize}

\section{Complexitate teoretică}

\begin{table}[H]
    \centering
    \caption{Tabel comparativ al complexităților algoritmilor analizați}
    \begin{tabular}{lccc}
    \toprule
    \textbf{Algoritm} & \textbf{Best case} & \textbf{Average} & \textbf{Worst Case} \\
    \midrule
    Quick Sort (Random Pivot) & $\mathcal{O}(n \log n)$ & $\mathcal{O}(n \log n)$ & $\mathcal{O}(n^2)$ \\
    Quick Sort (Median Pivot) & $\mathcal{O}(n \log n)$ & $\mathcal{O}(n \log n)$ & $\mathcal{O}(n \log n)$ \\
    Quick Sort (Half Pivot)   & $\mathcal{O}(n \log n)$ & $\mathcal{O}(n \log n)$ & $\mathcal{O}(n^2)$ \\
    Ternary Quick Sort        & $\mathcal{O}(n \log n)$ & $\mathcal{O}(n \log n)$ & $\mathcal{O}(n^2)$ \\
    Radix Sort (base 10)      & $\mathcal{O}(nk)$       & $\mathcal{O}(nk)$       & $\mathcal{O}(nk)$ \\
    Radix Sort (base 16)      & $\mathcal{O}(nk)$       & $\mathcal{O}(nk)$       & $\mathcal{O}(nk)$ \\
    Radix Sort ($2^{16}$)     & $\mathcal{O}(nk)$       & $\mathcal{O}(nk)$       & $\mathcal{O}(nk)$ \\
    Merge Sort                & $\mathcal{O}(n \log n)$ & $\mathcal{O}(n \log n)$ & $\mathcal{O}(n \log n)$ \\
    Intro Sort                & $\mathcal{O}(n \log n)$ & $\mathcal{O}(n \log n)$ & $\mathcal{O}(n \log n)$ \\
    Tim Sort                  & $\mathcal{O}(n)$        & $\mathcal{O}(n \log n)$ & $\mathcal{O}(n \log n)$ \\
    Shell Sort                & $\mathcal{O}(n \log n)$ & $\mathcal{O}(n^{5/4})$  & $\mathcal{O}(n^2)$ \\
    \bottomrule
    \end{tabular}
    \end{table}

\section{Implementare}

\begin{justify}
Toți algoritmii au fost organizați într-un repository GitHub, structurat clar.
Fiecare algoritm de sortare are propriul său header dedicat în folderul include/, iar
implementarea este realizată în fișiere .cpp separate.
\end{justify}


\section{Metodologie experimentală}

Pentru testarea performanțelor, am creat un sistem automatizat de rulare și înregistrare a testelor, organizat în jurul fișierului principal \texttt{main.cpp}. Setările fiecărui test sunt definite într-un fișier de configurare \texttt{test\_config.csv}, unde fiecare linie specifică: \texttt{nameoftest, numberofvalues, maxvalue}. Aceste configurații sunt parcurse și procesate cu ajutorul funcției \texttt{readTestConfigs()}, iar pentru fiecare algoritm de sortare implementat în sistem, se generează un vector aleatoriu corespunzător parametrilor testului.

Toți algoritmii sunt înregistrați într-un map, ce permite selectarea și rularea lor pe baza numelui.

Timpul de execuție pentru fiecare sortare este măsurat cu funcția \texttt{measureTime()}, iar rezultatele sunt salvate în fișierul \texttt{results.csv}, folosind funcția \texttt{logResult()} incluzând: numele testului, algoritmul, dimensiunea vectorului, valoarea maximă, timpul de execuție (în secunde) și dacă vectorul rezultat este sortat corect.

Pentru o testare completă, aplicația poate fi rulată cu comanda \texttt{./main all}, caz în care se rulează toți algoritmii în toate testele definite.

\bigskip

Fiecare algoritm este rulat o singură dată per configurație, iar logica poate fi extinsă ușor pentru repetare multiplă și calculul unei medii. Măsurarea timpului s-a realizat utilizând funcționalități din biblioteca standard \texttt{<chrono>}.

\section{Rezultate experimentale}

\subsection{Numere putine, valori dispersate}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{./img/img_20250417_020108.png} % Replace with your image file path and name
    \caption{Pentru 1000 de numere si valori intre 0 si $10^9$}
\end{figure}






\section{Concluzii}

\begin{itemize}
    \item Algoritmii simpli sunt potriviți doar pentru seturi mici de date.
    \item Quick Sort este ideal pentru cazuri generale, dar trebuie tratat cu atenție pentru cazurile nefavorabile.
    \item Merge Sort este fiabil și stabil, ideal pentru date mari și sortare externă.
\end{itemize}

\section*{Anexă: Cod sursă (fragment)}

\begin{verbatim}
void bubbleSort(int arr[], int n) {
    bool swapped;
    for (int i = 0; i < n-1; i++) {
        swapped = false;
        for (int j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                std::swap(arr[j], arr[j+1]);
                swapped = true;
            }
        }
        if (!swapped)
            break;
    }
}
\end{verbatim}

\end{document}
